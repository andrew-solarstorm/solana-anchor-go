package anchor_idl

import (
	"os"
	"path"
	"path/filepath"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/fragmetric-labs/solana-anchor-go/sighash"
	"github.com/gagliardetto/solana-go"
	. "github.com/gagliardetto/utilz"
)

func ToPackageName(s string) string {
	return sighash.ToRustSnakeCase(ToCamel(s))
}
func NewGoFile(programName string, includeBoilerplace bool) *File {
	file := NewFile(ToPackageName(programName))
	// Set a prefix to avoid collision between variable names and packages:
	file.PackagePrefix = "ag"
	// Add comment to file:
	// file.HeaderComment("Code generated by https://github.com/gagliardetto. DO NOT EDIT.")

	if includeBoilerplace {
		{
			// main function:
			// file.Func().Id("main").Params().Block()
		}
	}
	return file
}

// SaveGoFile encodes to a file the provided *jen.File.
func SaveGoFile(outDir string, assetFileName string, file *File) error {
	// Save Go assets:
	assetFilepath := path.Join(outDir, assetFileName)

	// Create file Golang file:
	goFile, err := os.Create(assetFilepath)
	if err != nil {
		panic(err)
	}
	defer goFile.Close()

	// Write generated Golang to file:
	Infof("Saving Golang assets to %q", MustAbs(assetFilepath))
	return file.Render(goFile)
}

func DoGroup(f func(*Group)) *Statement {
	g := &Group{}
	g.CustomFunc(Options{
		Multi: false,
	}, f)
	s := newStatement()
	*s = append(*s, g)
	return s
}

func DoGroupMultiline(f func(*Group)) *Statement {
	g := &Group{}
	g.CustomFunc(Options{
		Multi: true,
	}, f)
	s := newStatement()
	*s = append(*s, g)
	return s
}
func newStatement() *Statement {
	return &Statement{}
}

var sysVars = map[string]solana.PublicKey{
	"SysVarClockPubkey":             solana.SysVarClockPubkey,
	"SysVarEpochSchedulePubkey":     solana.SysVarEpochSchedulePubkey,
	"SysVarFeesPubkey":              solana.SysVarFeesPubkey,
	"SysVarInstructionsPubkey":      solana.SysVarInstructionsPubkey,
	"SysVarRecentBlockHashesPubkey": solana.SysVarRecentBlockHashesPubkey,
	"SysVarRentPubkey":              solana.SysVarRentPubkey,
	"SysVarSlotHashesPubkey":        solana.SysVarSlotHashesPubkey,
	"SysVarSlotHistoryPubkey":       solana.SysVarSlotHistoryPubkey,
	"SysVarStakeHistoryPubkey":      solana.SysVarStakeHistoryPubkey,
	"SysVarRewardsPubkey":           solana.SysVarRewardsPubkey,
}

func IsVar(name string) bool {
	return strings.HasPrefix(name, "$(") && strings.HasSuffix(name, ")")
}

func GetSysVarName(variable string) string {
	variable = strings.TrimPrefix(variable, "$(")
	variable = strings.TrimSuffix(variable, ")")
	return variable
}

func IsSysVar(name string) bool {
	_, ok := sysVars[name]
	return ok
}

func StringIf(condition bool, s string) string {
	if condition {
		return s
	}
	return ""
}

func CodeIf(condition bool, code Code) Code {
	if condition {
		return code
	}
	return Null()
}

// formatAccountAccessorName formats a name for a function that
// either gets or sets an account.
// If the RemoveAccountSuffix config flag is set, and the name already
// has an "Account" suffix, then another "Account" suffix is NOT added.
// E.g. ("Set", "Foo") => "SetFooAccount"
// E.g. ("Set", "BarAccount") => "SetBarAccount"
func formatAccountAccessorName(prefix, name string) string {
	endsWithAccount := strings.HasSuffix(strings.ToLower(name), "account")
	if !Conf.RemoveAccountSuffix || !endsWithAccount {
		return prefix + name + "Account"
	}
	return prefix + name
}

func treeFindLongestNameFromFields(fields []IdlField) (ln int) {
	for _, v := range fields {
		if len(v.Name) > ln {
			ln = len(v.Name)
		}
	}
	return
}

func treeFindLongestNameFromAccounts(accounts IdlAccountItemSlice) (ln int) {
	accounts.Walk("", nil, nil, func(groupPath string, accountIndex int, parentGroup *IdlAccounts, ia *IdlAccount) bool {

		cleanedName := treeFormatAccountName(ia.Name)

		exportedAccountName := filepath.Join(groupPath, cleanedName)
		if len(exportedAccountName) > ln {
			ln = len(exportedAccountName)
		}

		return true
	})
	return
}

func treeFormatAccountName(name string) string {
	cleanedName := name
	if IsSysVar(name) {
		cleanedName = strings.TrimSuffix(GetSysVarName(name), "PublicKey")
	}
	if len(cleanedName) > len("account") {
		if strings.HasSuffix(cleanedName, "account") {
			cleanedName = strings.TrimSuffix(cleanedName, "account")
		} else if strings.HasSuffix(cleanedName, "Account") {
			cleanedName = strings.TrimSuffix(cleanedName, "Account")
		}
	}
	return cleanedName
}
