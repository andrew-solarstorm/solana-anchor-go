package anchor_idl

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"time"

	. "github.com/dave/jennifer/jen"
	"github.com/davecgh/go-spew/spew"
	"github.com/fragmetric-labs/solana-anchor-go/sighash"
	bin "github.com/gagliardetto/binary"
	. "github.com/gagliardetto/utilz"
	"golang.org/x/mod/modfile"
)

const (
	PkgSolanaGo       = "github.com/gagliardetto/solana-go"
	PkgSolanaGoText   = "github.com/gagliardetto/solana-go/text"
	PkgDfuseBinary    = "github.com/gagliardetto/binary"
	PkgTreeout        = "github.com/gagliardetto/treeout"
	PkgFormat         = "github.com/gagliardetto/solana-go/text/format"
	PkgGoFuzz         = "github.com/gagliardetto/gofuzz"
	PkgTestifyRequire = "github.com/stretchr/testify/require"
)

type FileWrapper struct {
	Name string
	File *File
}

func typeStringToType(ts IdlTypeAsString) *Statement {
	stat := newStatement()
	switch ts {
	case IdlTypeBool:
		stat.Bool()
	case IdlTypeU8:
		stat.Uint8()
	case IdlTypeI8:
		stat.Int8()
	case IdlTypeU16:
		// TODO: some types have their implementation in github.com/gagliardetto/binary
		stat.Uint16()
	case IdlTypeI16:
		stat.Int16()
	case IdlTypeU32:
		stat.Uint32()
	case IdlTypeI32:
		stat.Int32()
	case IdlTypeU64:
		stat.Uint64()
	case IdlTypeI64:
		stat.Int64()
	case IdlTypeU128:
		stat.Qual(PkgDfuseBinary, "Uint128")
	case IdlTypeI128:
		stat.Qual(PkgDfuseBinary, "Int128")
	case IdlTypeBytes:
		stat.Index().Byte()
	case IdlTypeString:
		stat.String()
	case IdlTypePubkey:
		stat.Qual(PkgSolanaGo, "PublicKey")
	case IdlTypeF32:
		stat.Float32()
	case IdlTypeF64:
		stat.Float64()

	// Custom:
	case IdlTypeUnixTimestamp:
		stat.Qual(PkgSolanaGo, "UnixTimeSeconds")
	case IdlTypeHash:
		stat.Qual(PkgSolanaGo, "Hash")
	case IdlTypeDuration:
		stat.Qual(PkgSolanaGo, "DurationSeconds")

	default:
		panic(Sf("unknown type string: %s", ts))
	}

	return stat
}

func GenerateFromIDLs(filenames FlagStringArray, ts time.Time) {
	if len(filenames) == 0 {
		Sfln(
			"[%s] No IDL files provided",
			Red(XMark),
		)
		os.Exit(1)
	}
	{
		exists, err := DirExists(GetConfig().DstDir)
		if err != nil {
			panic(err)
		}
		if !exists {
			MustCreateFolderIfNotExists(GetConfig().DstDir, os.ModePerm)
		}
	}

	callbacks := make([]func(), 0)
	defer func() {
		for _, cb := range callbacks {
			cb()
		}
	}()

	for _, idlFilepath := range filenames {
		Sfln(
			"[%s] Generating client from IDL: %s",
			Shakespeare("+"),
			Shakespeare(idlFilepath),
		)
		idlFile, err := os.Open(idlFilepath)
		if err != nil {
			panic(err)
		}

		dec := json.NewDecoder(idlFile)

		var idl IDL

		err = dec.Decode(&idl)
		if err != nil {
			panic(err)
		}
		{
			if idl.State != nil {
				Sfln(
					"%s idl.State is defined, but generator is not implemented yet.",
					OrangeBG("[?]"),
				)
			}

		}

		// Create subfolder for package for generated assets:
		packageAssetFolderName := sighash.ToRustSnakeCase(idl.Metadata.Name)
		var dstDirForFiles string
		if GetConfig().Debug {
			packageAssetFolderPath := path.Join(GetConfig().DstDir, packageAssetFolderName)
			MustCreateFolderIfNotExists(packageAssetFolderPath, os.ModePerm)
			// Create folder for assets generated during this run:
			thisRunAssetFolderName := ToLowerCamel(idl.Metadata.Name) + "_" + ts.Format(FilenameTimeFormat)
			thisRunAssetFolderPath := path.Join(packageAssetFolderPath, thisRunAssetFolderName)
			// Create a new assets folder inside the main assets folder:
			MustCreateFolderIfNotExists(thisRunAssetFolderPath, os.ModePerm)
			dstDirForFiles = thisRunAssetFolderPath
		} else {
			if GetConfig().DstDir == generatedDir {
				dstDirForFiles = filepath.Join(GetConfig().DstDir, packageAssetFolderName)
			} else {
				dstDirForFiles = GetConfig().DstDir
			}
		}
		MustCreateFolderIfNotExists(dstDirForFiles, os.ModePerm)

		files, err := GenerateClientFromProgramIDL(idl)
		if err != nil {
			panic(err)
		}

		{
			mdf := &modfile.File{}
			mdf.AddModuleStmt(GetConfig().ModPath)

			mdf.AddNewRequire("github.com/gagliardetto/solana-go", "v1.12.0", false)
			mdf.AddNewRequire("github.com/gagliardetto/treeout", "v0.1.4", false)
			mdf.AddNewRequire("github.com/gagliardetto/gofuzz", "v1.2.2", false)
			mdf.AddNewRequire("github.com/stretchr/testify", "v1.6.1", false)
			mdf.AddNewRequire("github.com/davecgh/go-spew", "v1.1.1", false)
			mdf.Cleanup()

			if GetConfig().ModPath != "" {
				mfBytes, err := mdf.Format()
				if err != nil {
					panic(err)
				}
				gomodFilepath := filepath.Join(dstDirForFiles, "go.mod")
				Sfln(
					"[%s] %s",
					Lime(Checkmark),
					MustAbs(gomodFilepath),
				)
				// Write `go.mod` file:
				err = ioutil.WriteFile(gomodFilepath, mfBytes, 0666)
				if err != nil {
					panic(err)
				}
			}
		}

		for _, file := range files {

			file.File.HeaderComment("Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.")
			{
				// Save assets:
				assetFileName := file.Name + ".go"
				assetFilepath := path.Join(dstDirForFiles, assetFileName)

				// Create file:
				goFile, err := os.Create(assetFilepath)
				if err != nil {
					panic(err)
				}
				defer goFile.Close()

				// Write generated code file:
				Sfln(
					"[%s] %s",
					Lime(Checkmark),
					MustAbs(assetFilepath),
				)
				err = file.File.Render(goFile)
				if err != nil {
					panic(err)
				}
			}
		}
	}
}

func GenField(field IdlField, pointer bool) Code {
	st := newStatement()
	st.Id(ToCamel(field.Name)).
		Add(func() Code {
			if IsComplexEnum(field.Type) {
				return Op("*")
			}
			if pointer {
				return Op("*")
			}
			return nil
		}()).
		Add(GenTypeName(field.Type))
	return st
}

func GenTypeName(idlTypeEnv IdlType) Code {
	st := newStatement()
	switch {
	case idlTypeEnv.IsString():
		{
			st.Add(typeStringToType(idlTypeEnv.GetString()))
		}
	case idlTypeEnv.IsIdlTypeOption():
		{
			opt := idlTypeEnv.GetIdlTypeOption()
			// TODO: optional = pointer?
			st.Add(GenTypeName(opt.Option))
		}
	case idlTypeEnv.IsIdlTypeVec():
		{
			vec := idlTypeEnv.GetIdlTypeVec()
			st.Index().Add(GenTypeName(vec.Vec))
		}
	case idlTypeEnv.IsIdlTypeDefined():
		{
			st.Add(Id(idlTypeEnv.GetIdlTypeDefined().Defined.Name))
		}
	case idlTypeEnv.IsArray():
		{
			arr := idlTypeEnv.GetArray()
			st.Index(Id(Itoa(arr.Num))).Add(GenTypeName(arr.Elem))
		}
	default:
		panic(spew.Sdump(idlTypeEnv))
	}
	return st
}

func CodeToString(code Code) string {
	return Sf("%#v", code)
}

// typeRegistryComplexEnum contains all types that are a complex enum (and thus implemented as an interface).
var typeRegistryComplexEnum = make(map[string]struct{})

func IsComplexEnum(envel IdlType) bool {
	if envel.IsIdlTypeDefined() {
		_, ok := typeRegistryComplexEnum[envel.GetIdlTypeDefined().Defined.Name]
		return ok
	}
	return false
}

func AddTypeNameIsComplexEnum(name string) {
	typeRegistryComplexEnum[name] = struct{}{}
}

func RegisterComplexEnums(idl *IDL, def IdlTypeDef) {
	switch def.Type.Kind {
	case IdlTypeDefTyKindEnum:
		enumTypeName := def.Name
		if !def.Type.Variants.IsSimpleEnum() {
			AddTypeNameIsComplexEnum(enumTypeName)
		}
	}
}

func getElementFieldName(i int) string {
	return fmt.Sprintf("Elem_%d", i)
}

func GenTypeDef(idl *IDL, withDiscriminator *[8]byte, def IdlTypeDef) Code {
	st := newStatement()
	switch def.Type.Kind {
	case IdlTypeDefTyKindStruct:
		code := Empty()
		code.Type().Id(def.Name).StructFunc(func(fieldsGroup *Group) {
			if def.Type.Fields == nil {
				emptyFields := []IdlField{}
				def.Type.Fields = (*IdlStructFieldSlice)(&emptyFields)
			}
			for fieldIndex, field := range *def.Type.Fields {
				for docIndex, doc := range field.Docs {
					if docIndex == 0 && fieldIndex > 0 {
						fieldsGroup.Line()
					}
					fieldsGroup.Comment(doc)
				}
				fieldsGroup.Add(GenField(field, field.Type.IsIdlTypeOption())).
					Add(func() Code {
						if field.Type.IsIdlTypeOption() {
							return Tag(map[string]string{
								"bin": "optional",
							})
						}
						return nil
					}())
			}
		})
		st.Add(code.Line())

		{
			// generate encoder and decoder methods (for borsh):
			if GetConfig().Encoding == EncodingBorsh {
				code := Empty()
				exportedAccountName := ToCamel(def.Name)

				//toBeHashed := ToCamel(def.Name)

				if withDiscriminator != nil {
					discriminatorName := exportedAccountName + "Discriminator"
					//if GetConfig().Debug {
					//	code.Comment(Sf(`hash("%s:%s")`, bin.SIGHASH_ACCOUNT_NAMESPACE, toBeHashed)).Line()
					//}
					//sighash := bin.SighashTypeID(bin.SIGHASH_ACCOUNT_NAMESPACE, toBeHashed)

					sighash := bin.TypeID(*withDiscriminator)
					code.Var().Id(discriminatorName).Op("=").Index(Lit(8)).Byte().Op("{").ListFunc(func(byteGroup *Group) {
						for _, byteVal := range sighash[:] {
							byteGroup.Lit(int(byteVal))
						}
					}).Op("}")

					// Declare MarshalWithEncoder:
					code.Line().Line().Add(
						genMarshalWithEncoder_struct(
							idl,
							true,
							exportedAccountName,
							discriminatorName,
							*def.Type.Fields,
							true,
						))

					// Declare UnmarshalWithDecoder
					code.Line().Line().Add(
						genUnmarshalWithDecoder_struct(
							idl,
							true,
							exportedAccountName,
							discriminatorName,
							*def.Type.Fields,
							sighash,
						))
				} else {
					// Declare MarshalWithEncoder:
					code.Line().Line().Add(
						genMarshalWithEncoder_struct(
							idl,
							false,
							exportedAccountName,
							"",
							*def.Type.Fields,
							true,
						))

					// Declare UnmarshalWithDecoder
					code.Line().Line().Add(
						genUnmarshalWithDecoder_struct(
							idl,
							false,
							exportedAccountName,
							"",
							*def.Type.Fields,
							bin.TypeID{},
						))
				}

				st.Add(code.Line().Line())
			}
		}

	case IdlTypeDefTyKindEnum:
		code := newStatement()
		enumTypeName := def.Name

		if def.Type.Variants.IsSimpleEnum() {
			code.Type().Id(enumTypeName).Qual(PkgDfuseBinary, "BorshEnum")
			code.Line().Const().Parens(DoGroup(func(gr *Group) {
				for variantIndex, variant := range *def.Type.Variants {

					for docIndex, doc := range variant.Docs {
						if docIndex == 0 {
							gr.Line()
						}
						gr.Comment(doc).Line()
					}

					gr.Id(formatSimpleEnumVariantName(variant.Name, enumTypeName)).Add(func() Code {
						if variantIndex == 0 {
							return Id(enumTypeName).Op("=").Iota()
						}
						return nil
					}()).Line()
				}
				// TODO: check for fields, etc.
			}))

			// Generate stringer for the uint8 enum values:
			code.Line().Line().Func().Params(Id("value").Id(enumTypeName)).Id("String").
				Params().
				Params(String()).
				BlockFunc(func(body *Group) {
					body.Switch(Id("value")).BlockFunc(func(switchBlock *Group) {
						for _, variant := range *def.Type.Variants {
							switchBlock.Case(Id(formatSimpleEnumVariantName(variant.Name, enumTypeName))).Line().Return(Lit(variant.Name))
						}
						switchBlock.Default().Line().Return(Lit(""))
					})

				})
			st.Add(code.Line())
		} else {
			AddTypeNameIsComplexEnum(enumTypeName)
			interfaceTypeName := ToLowerCamel(enumTypeName)
			containerName := FormatEnumContainerName(enumTypeName)
			interfaceMethodName := FormatInterfaceMethodName(enumTypeName)

			// Declare the wrapper struct of the enum type interface
			code.Type().Id(enumTypeName).Struct(
				Id("Value").Qual("", interfaceTypeName),
			).Line().Line()

			{
				// Declare MarshalWithDecoder of the wrapper struct
				code.Line().Line().Add(
					GenMarshalWithEncoderEnum(
						enumTypeName,
						def.Type.Variants,
					))

				//// Declare UnmarshalWithDecoder of the wrapper struct
				code.Line().Line().Add(
					GenUnmarshalWithDecoderEnum(
						enumTypeName,
						def.Type.Variants,
					))
				code.Line().Line()
			}

			// Declare the interface of the enum type:
			code.Type().Id(interfaceTypeName).Interface(
				Id(interfaceMethodName).Call(),
			).Line().Line()

			// Declare the enum variants container (non-exported, used internally)
			code.Type().Id(containerName).StructFunc(
				func(structGroup *Group) {
					structGroup.Id("Enum").Qual(PkgDfuseBinary, "BorshEnum").Tag(map[string]string{
						"borsh_enum": "true",
					})

					for _, variant := range *def.Type.Variants {
						structGroup.Id(ToCamel(variant.Name)).Id(formatComplexEnumVariantTypeName(enumTypeName, variant.Name))
					}
				},
			).Line().Line()

			for _, variant := range *def.Type.Variants {
				// Name of the variant type if the enum is a complex enum (i.e. enum variants are inline structs):
				variantTypeNameComplex := formatComplexEnumVariantTypeName(enumTypeName, variant.Name)

				// Declare the enum variant types:
				if variant.IsUint8() {
					// TODO: make the name {variantTypeName}_{interface_name} ???
					code.Type().Id(variantTypeNameComplex).Uint8().Line().Line()
				} else {
					code.Type().Id(variantTypeNameComplex).StructFunc(
						func(structGroup *Group) {
							switch {
							case variant.Fields.IdlEnumFieldsNamed != nil:
								for _, variantField := range *variant.Fields.IdlEnumFieldsNamed {
									structGroup.Add(GenField(variantField, variantField.Type.IsIdlTypeOption())).
										Add(func() Code {
											if variantField.Type.IsIdlTypeOption() {
												return Tag(map[string]string{
													"bin": "optional",
												})
											}
											return nil
										}())
								}
							default:
								for i, variantTupleItem := range *variant.Fields.IdlEnumFieldsTuple {
									variantField := IdlField{
										Name: getElementFieldName(i),
										Type: variantTupleItem,
									}
									structGroup.Add(GenField(variantField, variantField.Type.IsIdlTypeOption())).
										Add(func() Code {
											if variantField.Type.IsIdlTypeOption() {
												return Tag(map[string]string{
													"bin": "optional",
												})
											}
											return nil
										}())
								}
							}
						},
					).Line().Line()
				}

				if variant.IsUint8() {
					// Declare MarshalWithEncoder
					code.Line().Line().Func().Params(Id("obj").Id(variantTypeNameComplex)).Id("MarshalWithEncoder").
						Params(
							ListFunc(func(params *Group) {
								// Parameters:
								params.Id("encoder").Op("*").Qual(PkgDfuseBinary, "Encoder")
							}),
						).
						Params(
							ListFunc(func(results *Group) {
								// Results:
								results.Err().Error()
							}),
						).
						BlockFunc(func(body *Group) {
							body.Return(Nil())
						})
					code.Line().Line()

					// Declare UnmarshalWithDecoder
					code.Func().Params(Id("obj").Op("*").Id(variantTypeNameComplex)).Id("UnmarshalWithDecoder").
						Params(
							ListFunc(func(params *Group) {
								// Parameters:
								params.Id("decoder").Op("*").Qual(PkgDfuseBinary, "Decoder")
							}),
						).
						Params(
							ListFunc(func(results *Group) {
								// Results:
								results.Err().Error()
							}),
						).
						BlockFunc(func(body *Group) {
							body.Return(Nil())
						})
					code.Line().Line()
				} else {
					if variant.Fields != nil && variant.Fields.IdlEnumFieldsNamed != nil {
						// Declare MarshalWithEncoder:
						code.Line().Line().Add(
							genMarshalWithEncoder_struct(
								idl,
								false,
								variantTypeNameComplex,
								"",
								*variant.Fields.IdlEnumFieldsNamed,
								true,
							))

						// Declare UnmarshalWithDecoder
						code.Line().Line().Add(
							genUnmarshalWithDecoder_struct(
								idl,
								false,
								variantTypeNameComplex,
								"",
								*variant.Fields.IdlEnumFieldsNamed,
								bin.TypeID{},
							))
						code.Line().Line()
					}

					if variant.Fields != nil && variant.Fields.IdlEnumFieldsNamed == nil && variant.Fields.IdlEnumFieldsTuple != nil {
						idlEnumTypeFields := []IdlField{}
						for i, variantTupleItem := range *variant.Fields.IdlEnumFieldsTuple {
							idlEnumTypeFields = append(idlEnumTypeFields, IdlField{
								Name: getElementFieldName(i),
								Type: variantTupleItem,
							})
						}

						code.Line().Line().Add(
							genMarshalWithEncoder_struct(
								idl,
								false,
								variantTypeNameComplex,
								"",
								idlEnumTypeFields,
								true,
							))

						// Declare UnmarshalWithDecoder
						code.Line().Line().Add(
							genUnmarshalWithDecoder_struct(
								idl,
								false,
								variantTypeNameComplex,
								"",
								idlEnumTypeFields,
								bin.TypeID{},
							))
						code.Line().Line()
					}
				}

				// Declare the method to implement the parent enum interface:
				if variant.IsUint8() {
					code.Func().Params(Id("_").Id(variantTypeNameComplex)).Id(interfaceMethodName).Params().Block().Line().Line()
				} else {
					// .Op("*") why had used pointer receiver?
					code.Func().Params(Id("_").Id(variantTypeNameComplex)).Id(interfaceMethodName).Params().Block().Line().Line()
				}
			}

			st.Add(code.Line().Line())
		}

		// panic(Sf("not implemented: %s", spew.Sdump(def)))
	default:
		panic(Sf("not implemented: %s", spew.Sdump(def.Type.Kind)))
	}
	return st
}

func FormatEnumContainerName(enumTypeName string) string {
	return ToLowerCamel(enumTypeName) + "Container"
}

func FormatInterfaceMethodName(enumTypeName string) string {
	return "is" + ToCamel(enumTypeName)
}

func FormatBuilderFuncName(insExportedName string) string {
	return "New" + insExportedName + "InstructionBuilder"
}

func FormatInstructionTypeName(insExportedName string) string {
	return insExportedName + "Instruction"
}

func FormatByteSliceName(insExportedName string) string {
	return ToCamel(ToLower(insExportedName)) + "Bytes"
}

func FormatConstantName(insExportedName string) string {
	return "Constant" + ToCamel(ToLower(insExportedName))
}

func GenMarshalWithEncoderEnum(
	receiverTypeName string,
	variants *IdlEnumVariantSlice,
) Code {
	code := Empty()
	{
		code.Func().Params(Id("obj").Id(receiverTypeName)).Id("MarshalWithEncoder").
			Params(
				ListFunc(func(params *Group) {
					// Parameters:
					params.Id("encoder").Op("*").Qual(PkgDfuseBinary, "Encoder")
				}),
			).
			Params(
				ListFunc(func(results *Group) {
					// Results:
					results.Err().Error()
				}),
			).BlockFunc(func(body *Group) {
			body.List(Id("tmp")).Op(":=").Id(FormatEnumContainerName(receiverTypeName)).Block()
			body.Switch(Id("realvalue").Op(":=").Id("obj").Dot("Value").Op(".").Parens(Type())).
				BlockFunc(func(switchGroup *Group) {
					if variants != nil {
						for variantIndex, variant := range variants.GetEnumVariantTypeName() {
							switchGroup.Case(Id(formatComplexEnumVariantTypeName(receiverTypeName, variant))).
								BlockFunc(func(caseGroup *Group) {
									caseGroup.Id("tmp").Dot("Enum").Op("=").Lit(variantIndex)
									caseGroup.Id("tmp").Dot(ToCamel(variant)).Op("=").Id("realvalue")
								})
						}
					}
				})
			body.Return(Id("encoder").Dot("Encode").Call(Id("tmp")))
		})
	}
	return code
}

func GenUnmarshalWithDecoderEnum(
	receiverTypeName string,
	variants *IdlEnumVariantSlice,
) Code {
	code := Empty()
	{
		code.Func().Params(Id("obj").Op("*").Id(receiverTypeName)).Id("UnmarshalWithDecoder").
			Params(
				ListFunc(func(params *Group) {
					// Parameters:
					params.Id("decoder").Op("*").Qual(PkgDfuseBinary, "Decoder")
				}),
			).
			Params(
				ListFunc(func(results *Group) {
					// Results:
					results.Err().Error()
				}),
			).BlockFunc(func(body *Group) {
			body.List(Id("tmp")).Op(":=").New(Id(FormatEnumContainerName(receiverTypeName)))
			body.Err().Op("=").Id("decoder").Dot("Decode").Call(Id("tmp"))
			body.If(
				Err().Op("!=").Nil(),
			).Block(
				Return(Err()),
			)
			body.Switch(Id("tmp").Dot("Enum")).
				BlockFunc(func(switchGroup *Group) {
					for variantIndex, variantName := range variants.GetEnumVariantTypeName() {
						switchGroup.Case(Lit(variantIndex)).
							BlockFunc(func(caseGroup *Group) {
								caseGroup.Id("obj").Dot("Value").Op("=").Id("tmp").Dot(ToCamel(variantName))
							})
					}
					switchGroup.Default().
						BlockFunc(func(caseGroup *Group) {
							caseGroup.Return(Qual("fmt", "Errorf").Call(Lit("unknown enum index: %v"), Id("tmp").Dot("Enum")))
						})
				})
			body.Return(Nil())
		})
	}
	return code
}

func genMarshalWithEncoder_struct(
	idl *IDL,
	withDiscriminator bool,
	receiverTypeName string,
	discriminatorName string,
	fields []IdlField,
	checkNil bool,
) Code {
	code := Empty()
	{
		// Declare MarshalWithEncoder
		code.Func().Params(Id("obj").Id(receiverTypeName)).Id("MarshalWithEncoder").
			Params(
				ListFunc(func(params *Group) {
					// Parameters:
					params.Id("encoder").Op("*").Qual(PkgDfuseBinary, "Encoder")
				}),
			).
			Params(
				ListFunc(func(results *Group) {
					// Results:
					results.Err().Error()
				}),
			).
			BlockFunc(func(body *Group) {
				// Body:
				if withDiscriminator && discriminatorName != "" {
					body.Comment("Write account discriminator:")
					body.Err().Op("=").Id("encoder").Dot("WriteBytes").Call(Id(discriminatorName).Index(Op(":")), False())
					body.If(Err().Op("!=").Nil()).Block(
						Return(Err()),
					)
				}

				for _, field := range fields {
					exportedArgName := ToCamel(field.Name)
					if field.Type.IsIdlTypeOption() {
						body.Commentf("Serialize `%s` param (optional):", exportedArgName)
					} else {
						body.Commentf("Serialize `%s` param:", exportedArgName)
					}
					if field.Type.IsIdlTypeOption() {
						if checkNil {
							body.BlockFunc(func(optGroup *Group) {
								// if nil:
								optGroup.If(Id("obj").Dot(ToCamel(field.Name)).Op("==").Nil()).Block(
									Err().Op("=").Id("encoder").Dot("WriteBool").Call(False()),
									If(Err().Op("!=").Nil()).Block(
										Return(Err()),
									),
								).Else().Block(
									Err().Op("=").Id("encoder").Dot("WriteBool").Call(True()),
									If(Err().Op("!=").Nil()).Block(
										Return(Err()),
									),
									Err().Op("=").Id("encoder").Dot("Encode").Call(Id("obj").Dot(exportedArgName)),
									If(Err().Op("!=").Nil()).Block(
										Return(Err()),
									),
								)
							})
						} else {
							body.BlockFunc(func(optGroup *Group) {
								// TODO: make optional fields of accounts a pointer.
								// Write as if not nil:
								optGroup.Err().Op("=").Id("encoder").Dot("WriteBool").Call(True())
								optGroup.If(Err().Op("!=").Nil()).Block(
									Return(Err()),
								)
								optGroup.Err().Op("=").Id("encoder").Dot("Encode").Call(Id("obj").Dot(exportedArgName))
								optGroup.If(Err().Op("!=").Nil()).Block(
									Return(Err()),
								)
							})
						}

					} else {
						body.Err().Op("=").Id("encoder").Dot("Encode").Call(Id("obj").Dot(exportedArgName))
						body.If(Err().Op("!=").Nil()).Block(
							Return(Err()),
						)
					}
				}
				//}
				body.Return(Nil())
			})
	}
	return code
}

func genUnmarshalWithDecoder_struct(
	idl *IDL,
	withDiscriminator bool,
	receiverTypeName string,
	discriminatorName string,
	fields []IdlField,
	sighash bin.TypeID,
) Code {
	code := Empty()
	{
		// Declare UnmarshalWithDecoder
		code.Func().Params(Id("obj").Op("*").Id(receiverTypeName)).Id("UnmarshalWithDecoder").
			Params(
				ListFunc(func(params *Group) {
					// Parameters:
					params.Id("decoder").Op("*").Qual(PkgDfuseBinary, "Decoder")
				}),
			).
			Params(
				ListFunc(func(results *Group) {
					// Results:
					results.Err().Error()
				}),
			).
			BlockFunc(func(body *Group) {
				// Body:
				if withDiscriminator && discriminatorName != "" {
					body.Comment("Read and check account discriminator:")
					body.BlockFunc(func(discReadBody *Group) {
						discReadBody.List(Id("discriminator"), Err()).Op(":=").Id("decoder").Dot("ReadTypeID").Call()
						discReadBody.If(Err().Op("!=").Nil()).Block(
							Return(Err()),
						)
						discReadBody.If(Op("!").Id("discriminator").Dot("Equal").Call(Id(discriminatorName).Index(Op(":")))).Block(
							Return(
								Qual("fmt", "Errorf").Call(
									Line().Lit("wrong discriminator: wanted %s, got %s"),
									Line().Lit(Sf("%v", sighash[:])),
									Line().Qual("fmt", "Sprint").Call(Id("discriminator").Index(Op(":"))),
								),
							),
						)
					})
				}

				for _, field := range fields {
					exportedArgName := ToCamel(field.Name)
					if field.Type.IsIdlTypeOption() {
						body.Commentf("Deserialize `%s` (optional):", exportedArgName)
					} else {
						body.Commentf("Deserialize `%s`:", exportedArgName)
					}
					if field.Type.IsIdlTypeOption() {
						body.BlockFunc(func(optGroup *Group) {
							// if nil:
							optGroup.List(Id("ok"), Err()).Op(":=").Id("decoder").Dot("ReadBool").Call()
							optGroup.If(Err().Op("!=").Nil()).Block(
								Return(Err()),
							)
							optGroup.If(Id("ok")).Block(
								Err().Op("=").Id("decoder").Dot("Decode").Call(Op("&").Id("obj").Dot(exportedArgName)),
								If(Err().Op("!=").Nil()).Block(
									Return(Err()),
								),
							)
						})
					} else {
						body.Err().Op("=").Id("decoder").Dot("Decode").Call(Op("&").Id("obj").Dot(exportedArgName))
						body.If(Err().Op("!=").Nil()).Block(
							Return(Err()),
						)
					}
				}
				//}
				body.Return(Nil())
			})
	}
	return code
}

func formatComplexEnumVariantTypeName(enumTypeName string, variantName string) string {
	return ToCamel(Sf("%s_%s_Tuple", enumTypeName, variantName))
}

func formatSimpleEnumVariantName(variantName string, enumTypeName string) string {
	return ToCamel(Sf("%s_%s", enumTypeName, variantName))
}
